"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowJS = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-explicit-any */
const tools_1 = require("../tools");
const common_1 = require("../common");
const context_1 = require("../context");
const utils_1 = require("../utils");
const core_1 = require("../core");
const log = (0, utils_1.logger)('engine');
/**
 * It runs the activity, and returns the value and exception
 *
 * @param {any} target - any - The target object that contains the method to be executed.
 * @param {string} method - The name of the method to be executed.
 * @param {MethodOptions} options - MethodOptions
 * @param {boolean} is_first_iteration - is first iteration
 *
 * @returns The value of the method, or the exception if there is one.
 */
function run(target, method, options, is_first_iteration) {
    var _a, _b, _c, _d, _e, _f, _g;
    return __awaiter(this, void 0, void 0, function* () {
        options.activity.token = options.token;
        options.activity.context = options.context;
        let value;
        let exception;
        try {
            options.token.status = context_1.Status.Running;
            options.context.status = context_1.Status.Running;
            log.info(`Activity ${(_a = options.activity.id) !== null && _a !== void 0 ? _a : options.activity.name} is running`);
            let node;
            const nodes = Reflect.getMetadata(common_1.NodeKey, target, '$__metadata__');
            if (options.activity.name)
                node = nodes[options.activity.name];
            if (!node && options.activity.id)
                node = nodes[options.activity.id];
            log.info(`Node %o is loaded`, node);
            if (!method && !((_b = node === null || node === void 0 ? void 0 : node.options) === null || _b === void 0 ? void 0 : _b.pause)) {
                log.warn(`Activity ${(_c = options.activity.id) !== null && _c !== void 0 ? _c : options.activity.name} method not defined`);
                value = options.value;
                options.activity.takeOutgoing();
            }
            else if (!((_d = node === null || node === void 0 ? void 0 : node.options) === null || _d === void 0 ? void 0 : _d.pause) || is_first_iteration) {
                value = yield target[method](options);
            }
            else
                options.token.pause();
            log.info(`Activity ${(_e = options.activity.id) !== null && _e !== void 0 ? _e : options.activity.name} processed`);
            /* This is the code that is responsible for pausing the workflow token. */
            if (options.activity.isEnd())
                options.token.status = context_1.Status.Terminated;
            if (!((_f = options.activity.outgoing) === null || _f === void 0 ? void 0 : _f.length) && !options.activity.isEnd())
                options.token.pause();
        }
        catch (error) {
            options.context.status = context_1.Status.Failed;
            options.token.status = context_1.Status.Failed;
            exception = error;
            log.error(`Activity ${(_g = options.activity.id) !== null && _g !== void 0 ? _g : options.activity.name} failed with error %O`, error);
        }
        return { value, exception };
    });
}
/* It executes a workflow */
class WorkflowJS {
    /**
     * > The `build` function is a static method that returns a new instance of the `WorkflowJS` class
     *
     * @param [exec] - This is the object that contains the parameters that will be passed to the
     * workflow.
     *
     * @returns A new instance of the WorkflowJS class.
     */
    static build(exec) {
        const workflow = new this();
        if (exec) {
            workflow.target = exec === null || exec === void 0 ? void 0 : exec.target;
            workflow.context = exec === null || exec === void 0 ? void 0 : exec.context;
            workflow.process = exec === null || exec === void 0 ? void 0 : exec.process;
            workflow.definition = exec === null || exec === void 0 ? void 0 : exec.definition;
        }
        return workflow;
    }
    /**
     * It executes a workflow
     *
     * @param {ExecutionInterface} options - ExecutionInterface
     *
     * @returns The return value is an object with the following properties:
     */
    execute(_a) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
        var { context, data, value } = _a, options = __rest(_a, ["context", "data", "value"]);
        return __awaiter(this, void 0, void 0, function* () {
            context = ((_c = (_b = this.context) !== null && _b !== void 0 ? _b : context) !== null && _c !== void 0 ? _c : context_1.Context.build({ data })).resume();
            if (!context.isReady())
                throw new Error('Context is not ready to consume');
            if (context.status === context_1.Status.Terminated)
                throw new Error('Cannot execute workflow at terminated state');
            if (!this.target && ((_d = options === null || options === void 0 ? void 0 : options.exec) === null || _d === void 0 ? void 0 : _d.target))
                this.target = options.exec.target;
            if (!this.process && ((_e = options === null || options === void 0 ? void 0 : options.exec) === null || _e === void 0 ? void 0 : _e.process))
                this.process = options.exec.process;
            if (!this.definition && options.id)
                this.definition = core_1.Container.getDefinition(options.id);
            if (!this.definition && ((_f = options.exec) === null || _f === void 0 ? void 0 : _f.definition))
                this.definition = options.exec.definition;
            const { path, xml, schema } = options;
            if (!this.definition && schema)
                this.definition = schema;
            else if (!this.definition && xml)
                this.definition = (0, utils_1.parse)(xml)['bpmn:definitions'];
            else if (!this.definition && path)
                this.definition = (0, utils_1.parse)((0, utils_1.readFile)(path))['bpmn:definitions'];
            if (!this.target) {
                const { handler, factory } = options;
                this.target = '$__metadata__' in this ? this : (_g = (factory !== null && factory !== void 0 ? factory : (() => undefined))()) !== null && _g !== void 0 ? _g : handler;
                if (!this.target)
                    throw new Error('Target workflow not found');
            }
            const metadata = this.target.$__metadata__;
            this.definition = (_h = this.definition) !== null && _h !== void 0 ? _h : core_1.Container.getDefinition(metadata.definition.id);
            if (!this.definition)
                throw new Error('Definition schema not found');
            log.info(`Definition %o is loaded`, metadata.definition);
            this.process = (_j = this.process) !== null && _j !== void 0 ? _j : (0, tools_1.getBPMNProcess)(this.definition, metadata.process);
            if (!this.process)
                throw new Error('Process definition not found');
            log.info(`Process %o is loaded`, metadata.process);
            /* Checking if the options has a node, if it does, it will get the activity from the process. If it
            does not, it will check if the context has tokens. If it does not, it will get the start event
            from the process. If it does, it will throw an error. */
            let activity;
            if ((options === null || options === void 0 ? void 0 : options.node) && context.tokens.length) {
                activity = (0, tools_1.getActivity)(this.process, (0, tools_1.getWrappedBPMNElement)(this.process, options.node));
            }
            else if (!context.tokens.length && !(options === null || options === void 0 ? void 0 : options.node)) {
                if (!this.process['bpmn:startEvent'] || this.process['bpmn:startEvent'].length !== 1)
                    throw new Error('Start event is not defined in process or have more than one start event');
                activity = (0, tools_1.getActivity)(this.process, {
                    key: 'bpmn:startEvent',
                    element: this.process['bpmn:startEvent'][0],
                });
            }
            if (!activity)
                throw new Error('Node activity not found or not applicable');
            /* Checking if the context has tokens. If it does not, it creates a new token and adds it to the
            context. If it does, it gets the last token from the context and resumes it. */
            let token;
            if (context.tokens.length == 0) {
                const state = context_1.State.build(activity.id, { name: activity.name, value });
                token = context_1.Token.build({ history: [state] });
                context.addToken(token);
            }
            else {
                token = (_l = (_k = context.getTokens(activity.$)) === null || _k === void 0 ? void 0 : _k.pop()) === null || _l === void 0 ? void 0 : _l.resume();
                if (!(token === null || token === void 0 ? void 0 : token.isReady()))
                    throw new Error('Token is not ready to consume');
            }
            if (!token)
                throw new Error('Token not found');
            else
                token.state.value = (_m = token.state.value) !== null && _m !== void 0 ? _m : value;
            let node;
            const nodes = Reflect.getMetadata(common_1.NodeKey, this.target, '$__metadata__');
            if (activity.name)
                node = nodes[activity.name];
            if (!node && activity.id)
                node = nodes[activity.id];
            log.info(`Node %o is loaded`, node);
            const runOptions = {
                method: (_o = node === null || node === void 0 ? void 0 : node.propertyName) !== null && _o !== void 0 ? _o : '',
                options: { activity, token, context, data: data !== null && data !== void 0 ? data : context.data, value },
            };
            /* A loop that will run until the context status is not running. */
            let is_first_iteration = true;
            let val = {}; // to hold returned value by token id
            do {
                const result = yield run(this.target, runOptions.method, runOptions.options, is_first_iteration);
                log.debug(`Result of %o method is %O`, runOptions.method, (_p = result.value) !== null && _p !== void 0 ? _p : '[null]');
                if (result.exception)
                    throw result.exception;
                if (context.status === context_1.Status.Running) {
                    const next = context.next();
                    log.info(`Next node is ${(_r = (_q = next === null || next === void 0 ? void 0 : next.name) !== null && _q !== void 0 ? _q : next === null || next === void 0 ? void 0 : next.ref) !== null && _r !== void 0 ? _r : '[undefined]'}`);
                    if (!next)
                        break;
                    runOptions.method = '';
                    if (next.name)
                        runOptions.method = (_t = (_s = nodes[next.name]) === null || _s === void 0 ? void 0 : _s.propertyName) !== null && _t !== void 0 ? _t : '';
                    if (!runOptions.method)
                        runOptions.method = (_v = (_u = nodes[next.ref]) === null || _u === void 0 ? void 0 : _u.propertyName) !== null && _v !== void 0 ? _v : '';
                    if (!runOptions.method && result.value)
                        val = { [token.id]: result.value };
                    else if (runOptions.method && val[token.id]) {
                        next.value = val[token.id];
                        delete val[token.id];
                    }
                    else
                        next.value = result.value;
                    log.info(`Next method is ${(_w = runOptions.method) !== null && _w !== void 0 ? _w : '[undefined]'}`);
                    token = (_x = context.getTokens({ id: next.ref })) === null || _x === void 0 ? void 0 : _x.find((t) => t.status === context_1.Status.Ready);
                    if (!token)
                        throw new Error('Token not found at running stage');
                    activity = (0, tools_1.getActivity)(this.process, (0, tools_1.getWrappedBPMNElement)(this.process, { id: next.ref }));
                    log.info(`Next Activity is ${(_z = (_y = activity === null || activity === void 0 ? void 0 : activity.name) !== null && _y !== void 0 ? _y : activity === null || activity === void 0 ? void 0 : activity.id) !== null && _z !== void 0 ? _z : '[undefined]'}`);
                    runOptions.options = {
                        token,
                        activity,
                        context: context,
                        value: next.value,
                        data: data !== null && data !== void 0 ? data : context.data,
                    };
                }
                is_first_iteration = false;
            } while (context.status === context_1.Status.Running);
            /* Setting the status of the context to the appropriate status. */
            if (context.isTerminated())
                context.status = context_1.Status.Terminated;
            else if (context.status === context_1.Status.Running)
                context.status = context_1.Status.Paused;
            log.info(`Context status is ${context.status}`);
            return {
                context: context,
                target: this.target,
                process: this.process,
                definition: this.definition,
            };
        });
    }
}
exports.WorkflowJS = WorkflowJS;
//# sourceMappingURL=workflow.js.map