"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Activity = void 0;
const tools_1 = require("../../tools");
const context_1 = require("../../context");
const attribute_1 = require("./attribute");
const sequence_1 = require("./sequence");
/* It's a class that represents an activity in a BPMN file */
class Activity extends attribute_1.Attribute {
    constructor(process, data, key) {
        super(process, data);
        this.key = key;
    }
    /**
     * > The `incoming` property returns an array of `Sequence` objects that are incoming to the current
     * `Activity`
     *
     * @returns An array of Sequence objects.
     */
    get incoming() {
        var _a;
        return (_a = this['bpmn:incoming']) === null || _a === void 0 ? void 0 : _a.map((id) => {
            var _a;
            const flow = (_a = (0, tools_1.getWrappedBPMNElement)(this.process, { id })) === null || _a === void 0 ? void 0 : _a.element;
            if (flow)
                return sequence_1.Sequence.build(flow, this.process);
        }).filter((f) => f instanceof sequence_1.Sequence);
    }
    /**
     * > It returns an array of `Sequence` objects that are outgoing from the current activity
     *
     * @returns An array of Sequence objects
     */
    get outgoing() {
        var _a;
        return (_a = this['bpmn:outgoing']) === null || _a === void 0 ? void 0 : _a.map((id) => {
            var _a;
            const flow = (_a = (0, tools_1.getWrappedBPMNElement)(this.process, { id })) === null || _a === void 0 ? void 0 : _a.element;
            if (flow)
                return sequence_1.Sequence.build(flow, this.process);
        }).filter((f) => f instanceof sequence_1.Sequence);
    }
    /**
     * It takes the outgoing sequence flows from the current activity and creates a new token for each
     * one
     *
     * @param {IdentityOptions} [identity] - IdentityOptions
     * @param [options] - pause: boolean | string
     *
     * @returns The outgoing activity
     */
    takeOutgoing(identity, options) {
        var _a;
        if (!this.outgoing || !((_a = this.outgoing) === null || _a === void 0 ? void 0 : _a.length))
            return;
        const outgoing = (0, tools_1.takeOutgoing)(this.outgoing, identity);
        if (!outgoing)
            return;
        this.goOut(outgoing.map((out) => ({ activity: out, pause: options === null || options === void 0 ? void 0 : options.pause })));
    }
    /**
     * The function takes an array of options, retrieves corresponding activities from an outgoing array,
     * and passes them to another function.
     *
     * @param {TakeOutgoingInterface[]} options - An array of objects with two properties: "identity" and
     * "pause". "identity" is a string representing the identity of the outgoing activity to be taken out,
     * and "pause" is a boolean indicating whether the activity should be paused or not.
     *
     * @returns If the `outgoing` property is falsy or an empty array, nothing is returned.
     */
    takeOutgoings(options) {
        var _a, _b;
        if (!this.outgoing || !((_a = this.outgoing) === null || _a === void 0 ? void 0 : _a.length))
            return;
        const outgoing = {};
        for (const option of options) {
            const { identity, pause } = option;
            const activity = (_b = (0, tools_1.takeOutgoing)(this.outgoing, identity)) === null || _b === void 0 ? void 0 : _b.pop();
            if (activity)
                outgoing[activity.id] = { activity, pause };
        }
        this.goOut(Object.values(outgoing));
    }
    /**
     * The function handles outgoing transitions for a token in a workflow system.
     *
     * @param {GoOutInterface[]} outgoing - `outgoing` is an array of objects of type `GoOutInterface`. Each object
     * represents an outgoing transition from a current activity to a new activity.
     */
    goOut(outgoing) {
        const pause = (out) => typeof out.pause === 'string'
            ? out.pause === out.activity.id || out.pause === out.activity.name
            : out.pause;
        if ((outgoing === null || outgoing === void 0 ? void 0 : outgoing.length) && this.token) {
            if (outgoing.length === 1) {
                this.token.status = context_1.Status.Completed;
                const out = outgoing.pop();
                this.token.push(context_1.State.build(out.activity.id, {
                    name: out.activity.name,
                    status: pause(out) ? context_1.Status.Paused : context_1.Status.Ready,
                }));
            }
            if (outgoing.length > 1 && this.context) {
                this.token.locked = true;
                this.token.status = context_1.Status.Terminated;
                for (const out of outgoing) {
                    const token = context_1.Token.build({
                        parent: this.token.id,
                    });
                    token.push(context_1.State.build(out.activity.id, {
                        name: out.activity.name,
                        status: pause(out) ? context_1.Status.Paused : context_1.Status.Ready,
                    }));
                    this.context.addToken(token);
                }
            }
        }
    }
    /**
     * If the key property of the current node is not null and includes the string 'endEvent', return
     * true
     *
     * @returns The key of the current node.
     */
    isEnd() {
        var _a;
        return (_a = this.key) === null || _a === void 0 ? void 0 : _a.includes('endEvent');
    }
    /**
     * If the key property exists and includes the string 'startEvent', return true. Otherwise, return
     * false
     *
     * @returns A boolean value.
     */
    isStart() {
        var _a;
        return (_a = this.key) === null || _a === void 0 ? void 0 : _a.includes('startEvent');
    }
    /**
     * It creates a new Activity object.
     *
     * @param {BPMNActivity} el - BPMNActivity - the element from the BPMN file
     * @param {BPMNProcess} process - The process that the activity belongs to.
     * @param {string} [key] - The key of the element.
     *
     * @returns A new instance of the Activity class.
     */
    static build(el, process, key) {
        return new Activity(process, Object.assign({}, el), key);
    }
}
exports.Activity = Activity;
//# sourceMappingURL=activity.js.map